vector store

import uuid
from typing import Any, Dict, List, Optional
import numpy as np

from app.config import settings
from app.core.database import get_database_pool, is_database_initialized
from app.services.embedding import embedding_service
from loguru import logger

class PGVectorStoreService:
    def __init__(self):
        self.embedding_dim = 384  # Размерность для multilingual-MiniLM-L12-v2
        self.pool = None
        self.initialized = False

    async def init(self):
        """Initialize connection pool"""
        try:
            if not is_database_initialized():
                logger.info("Инициализация пула соединений с базой данных...")
                self.pool = await get_database_pool()
                self.initialized = True
                logger.info("Vector store service initialized successfully")
            else:
                self.pool = await get_database_pool()
                self.initialized = True
        except Exception as e:
            logger.error(f"Ошибка инициализации vector store: {e}")
            raise

    async def ensure_connection(self):
        """Убедиться, что соединение активно"""
        if not self.initialized or self.pool is None or self.pool._closed:
            logger.warning("Пул соединений недоступен, переинициализация...")
            await self.init()

    def _embedding_to_pgvector(self, embedding) -> str:
        """Преобразование эмбеддинга в строку для PostgreSQL vector"""
        if hasattr(embedding, 'tolist'):
            embedding_list = embedding.tolist()
        else:
            embedding_list = embedding
            
        # Преобразуем в строку формата: [1.0, 2.0, 3.0, ...]
        vector_str = '[' + ','.join(str(x) for x in embedding_list) + ']'
        return vector_str

    async def add_documents(
        self, documents: List[str], metadatas: List[Dict[str, Any]] = None
    ) -> List[str]:
        """Добавление документов в векторное хранилище PostgreSQL"""
        if not documents:
            logger.warning("Попытка добавить пустой список документов")
            return []

        await self.ensure_connection()

        if metadatas is None:
            metadatas = [{}] * len(documents)
        elif len(metadatas) != len(documents):
            logger.warning("Количество метаданных не совпадает с количеством документов")
            metadatas = [{}] * len(documents)

        try:
            # Создаем эмбеддинги
            logger.info(f"Создание эмбеддингов для {len(documents)} документов...")
            embeddings = embedding_service.encode(documents)

            ids = []
            async with self.pool.acquire() as conn:
                for i, (doc, embedding, metadata) in enumerate(zip(documents, embeddings, metadatas)):
                    doc_id = str(uuid.uuid4())
                    # Преобразуем эмбеддинг в строку для PostgreSQL
                    embedding_str = self._embedding_to_pgvector(embedding)
                    
                    await conn.execute('''
                        INSERT INTO documents (id, content, embedding, metadata)
                        VALUES ($1, $2, $3::vector, $4)
                    ''', doc_id, doc, embedding_str, metadata)
                    
                    ids.append(doc_id)

            logger.success(f"Добавлено {len(documents)} документов в PostgreSQL")
            return ids

        except Exception as e:
            logger.error(f"Ошибка добавления документов в PostgreSQL: {e}")
            # Попробуем переинициализировать пул при ошибке
            self.initialized = False
            raise

    async def search(self, query: str, top_k: Optional[int] = None) -> List[Dict[str, Any]]:
        """Поиск похожих документов в PostgreSQL"""
        if top_k is None:
            top_k = settings.TOP_K

        await self.ensure_connection()

        try:
            # Создаем эмбеддинг для запроса
            query_embedding = embedding_service.encode(query)
            query_embedding_str = self._embedding_to_pgvector(query_embedding)

            async with self.pool.acquire() as conn:
                # Используем косинусное расстояние
                results = await conn.fetch('''
                    SELECT 
                        id,
                        content,
                        metadata,
                        1 - (embedding <=> $1::vector) as similarity
                    FROM documents
                    ORDER BY embedding <=> $1::vector
                    LIMIT $2
                ''', query_embedding_str, top_k)

                formatted_results = []
                for row in results:
                    formatted_results.append({
                        "id": str(row["id"]),
                        "document": row["content"],
                        "metadata": row["metadata"] or {},
                        "distance": 1 - float(row["similarity"]),
                        "score": float(row["similarity"])
                    })

                logger.debug(f"Найдено {len(formatted_results)} релевантных документов")
                return formatted_results

        except Exception as e:
            logger.error(f"Ошибка поиска в PostgreSQL: {e}")
            # Попробуем переинициализировать пул при ошибке
            self.initialized = False
            return []

    async def get_collection_info(self) -> Dict[str, Any]:
        """Получение информации о коллекции документов"""
        await self.ensure_connection()

        try:
            async with self.pool.acquire() as conn:
                count = await conn.fetchval("SELECT COUNT(*) FROM documents")
                return {
                    "database": "PostgreSQL",
                    "table_name": "documents",
                    "document_count": count,
                    "status": "healthy",
                    "vector_dimension": self.embedding_dim
                }
        except Exception as e:
            logger.error(f"Ошибка получения информации о коллекции: {e}")
            self.initialized = False
            return {
                "database": "PostgreSQL",
                "table_name": "documents",
                "document_count": 0,
                "status": "error",
                "error": str(e)
            }

    async def delete_all_documents(self):
        """Удаление всех документов (для тестирования)"""
        await self.ensure_connection()

        try:
            async with self.pool.acquire() as conn:
                await conn.execute("DELETE FROM documents")
                logger.info("Все документы удалены из PostgreSQL")
        except Exception as e:
            logger.error(f"Ошибка удаления документов: {e}")
            self.initialized = False
            raise

# Global instance
vector_store = PGVectorStoreService()

