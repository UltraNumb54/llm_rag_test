def format_model_response(self, text: str) -> str:
    """Форматирование ответа модели для корректного отображения в HTML"""
    if not text:
        return text
        
    # Замена символов переноса и других специальных символов
    formatted_text = (text
        .replace('\n', '<br>')  # Переносы строк
        .replace('\t', '    ')  # Табуляция
        .replace('  ', '  ')   # Неразрывные пробелы
    )
    
    # Дополнительная обработка маркированных списков
    formatted_text = re.sub(r'^\s*[\-\*]\s+', '• ', formatted_text, flags=re.MULTILINE)
    
    return formatted_text

# метод generate_with_context:
def generate_with_context(self, question: str, context: List[str], conversation_history: Optional[List[Dict]] = None) -> str:
    # ... существующий код ...
    result = response.choices[0].message.content.strip()
    formatted_result = self.format_model_response(result)  # Добавьте эту строку
    return formatted_result

function addMessage(role, content, isTyping = false) {
    // ... существующий код ...
    if (isTyping) {
        // ... индикатор набора ...
    } else {
        const roleNames = {
            'user': 'Вы',
            'assistant': 'Ассистент', 
            'system': 'Система',
            'error': 'Ошибка'
        };
        
        // Используйте innerHTML вместо textContent для поддержки HTML-разметки
        messageDiv.innerHTML = `<strong>${roleNames[role]}:</strong> ${content}`;
    }
    // ... остальной код ...
}
