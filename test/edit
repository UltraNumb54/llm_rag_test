# app/services/vllm_manager.py
import subprocess
import time
import requests
import threading
from loguru import logger
from app.config import settings

class VLLMManager:
    def __init__(self):
        self.process = None
        self.is_running = False

    def start_vllm_server(self):
        """Запускает vLLM сервер в отдельном процессе"""
        try:
            # Команда для запуска vLLM
            cmd = [
                "vllm", "serve",
                settings.VLLM_MODEL_NAME,
                "--host", "0.0.0.0",
                "--port", "8080",  # Используем порт 8080 для vLLM
                "--dtype", "half",
                "--gpu-memory-utilization", "0.8"
            ]
            
            logger.info(f"Запуск vLLM сервера: {' '.join(cmd)}")
            
            # Запускаем процесс
            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            # Запускаем мониторинг вывода в отдельном потоке
            threading.Thread(target=self._monitor_output, daemon=True).start()
            
            # Ждем запуска сервера
            if self._wait_for_server():
                self.is_running = True
                logger.success("vLLM сервер успешно запущен")
                return True
            else:
                logger.error("Не удалось запустить vLLM сервер")
                return False
                
        except Exception as e:
            logger.error(f"Ошибка при запуске vLLM: {e}")
            return False

    def _monitor_output(self):
        """Мониторинг вывода vLLM сервера"""
        while self.process and self.process.poll() is None:
            output = self.process.stdout.readline()
            if output:
                logger.info(f"vLLM: {output.strip()}")

    def _wait_for_server(self, timeout=60):
        """Ожидает пока vLLM сервер станет доступен"""
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                response = requests.get(f"{settings.VLLM_BASE_URL}/models", timeout=5)
                if response.status_code == 200:
                    return True
            except:
                pass
            time.sleep(2)
        return False

    def stop_vllm_server(self):
        """Останавливает vLLM сервер"""
        if self.process:
            self.process.terminate()
            try:
                self.process.wait(timeout=10)
            except subprocess.TimeoutExpired:
                self.process.kill()
            self.is_running = False
            logger.info("vLLM сервер остановлен")

# Глобальный экземпляр
vllm_manager = VLLMManager()


# Обновление пакетов
sudo apt update

# Установка PostgreSQL
sudo apt install postgresql postgresql-contrib

# Запуск службы
sudo service postgresql start

# Включение автозапуска
sudo systemctl enable postgresql

# Установка зависимостей для сборки
sudo apt install build-essential postgresql-server-dev-14

# Скачивание и установка pgvector
cd /tmp
git clone https://github.com/pgvector/pgvector.git
cd pgvector
make
sudo make install

# Подключение к PostgreSQL и создание расширения
sudo -u postgres psql

CREATE EXTENSION vector;
\q

# Создание пользователя и базы данных
sudo -u postgres createuser -P -s rag_user  # Задайте пароль
sudo -u postgres createdb -O rag_user rag_db

psycopg2-binary==2.9.10
pgvector==0.2.6
sqlalchemy==2.0.38
asyncpg==0.29.0

pip install psycopg2-binary pgvector sqlalchemy asyncpg

# app/core/postgres_db.py
import asyncpg
from sqlalchemy import create_engine, Column, Integer, String, Text, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from pgvector.sqlalchemy import Vector
from app.config import settings
from loguru import logger
import numpy as np

Base = declarative_base()

class DocumentModel(Base):
    __tablename__ = "documents"
    
    id = Column(Integer, primary_key=True, index=True)
    content = Column(Text, nullable=False)
    embedding = Column(Vector(384))  # Для модели MiniLM-L12-v2
    metadata = Column(JSON)
    document_id = Column(String, unique=True, index=True)

class PostgreSQLManager:
    def __init__(self):
        self.engine = None
        self.SessionLocal = None
        self.async_pool = None

    def init_sync_connection(self):
        """Инициализация синхронного подключения для SQLAlchemy"""
        try:
            # Формат: postgresql://user:password@localhost:5432/dbname
            sync_database_url = f"postgresql://{settings.DB_USER}:{settings.DB_PASSWORD}@{settings.DB_HOST}:{settings.DB_PORT}/{settings.DB_NAME}"
            
            self.engine = create_engine(sync_database_url)
            self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)
            
            # Создаем таблицы
            Base.metadata.create_all(bind=self.engine)
            logger.success("PostgreSQL подключен синхронно")
            
        except Exception as e:
            logger.error(f"Ошибка подключения к PostgreSQL: {e}")
            raise

    async def init_async_connection(self):
        """Инициализация асинхронного подключения"""
        try:
            self.async_pool = await asyncpg.create_pool(
                user=settings.DB_USER,
                password=settings.DB_PASSWORD,
                database=settings.DB_NAME,
                host=settings.DB_HOST,
                port=settings.DB_PORT
            )
            logger.success("PostgreSQL подключен асинхронно")
        except Exception as e:
            logger.error(f"Ошибка асинхронного подключения к PostgreSQL: {e}")
            raise

    def get_session(self):
        """Получение синхронной сессии"""
        if not self.SessionLocal:
            self.init_sync_connection()
        return self.SessionLocal()

    async def get_async_connection(self):
        """Получение асинхронного подключения"""
        if not self.async_pool:
            await self.init_async_connection()
        return self.async_pool

    async def search_similar(self, embedding: list, limit: int = 5):
        """Поиск похожих документов"""
        conn = await self.get_async_connection()
        embedding_array = np.array(embedding)
        
        try:
            # Используем cosine расстояние
            results = await conn.fetch("""
                SELECT content, metadata, document_id,
                       embedding <=> $1 as distance
                FROM documents 
                ORDER BY embedding <=> $1
                LIMIT $2
            """, embedding_array, limit)
            
            return [
                {
                    "document": row["content"],
                    "metadata": row["metadata"],
                    "document_id": row["document_id"],
                    "distance": row["distance"]
                }
                for row in results
            ]
        except Exception as e:
            logger.error(f"Ошибка поиска: {e}")
            return []

    async def add_document(self, content: str, embedding: list, metadata: dict = None, document_id: str = None):
        """Добавление документа в базу"""
        conn = await self.get_async_connection()
        embedding_array = np.array(embedding)
        
        try:
            await conn.execute("""
                INSERT INTO documents (content, embedding, metadata, document_id)
                VALUES ($1, $2, $3, $4)
            """, content, embedding_array, metadata or {}, document_id)
            return True
        except Exception as e:
            logger.error(f"Ошибка добавления документа: {e}")
            return False

# Глобальный экземпляр
postgres_manager = PostgreSQLManager()

# app/config.py
from typing import List, Optional
from pydantic import Field
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # Настройки сервера
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # Модели
    EMBEDDING_MODEL: str = "sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2"
    RERANKER_MODEL: str = "cross-encoder/ms-marco-MiniLM-L-6-v2"
    
    # vLLM настройки
    VLLM_BASE_URL: str = "http://localhost:8080/v1"
    VLLM_API_KEY: str = "none"
    VLLM_MODEL_NAME: str = "Qwen/Qwen2.5-7B-Instruct-AWQ"

    # PostgreSQL настройки (заменяем ChromaDB)
    DB_HOST: str = "localhost"
    DB_PORT: int = 5432
    DB_NAME: str = "rag_db"
    DB_USER: str = "rag_user"
    DB_PASSWORD: str = "your_password_here"  # Задайте пароль

    # Остальные настройки
    COLLECTION_NAME: str = "tech_support_docs"
    CHUNK_SIZE: int = 500
    CHUNK_OVERLAP: int = 50
    MAX_FILE_SIZE: int = 100 * 1024 * 1024
    TOP_K: int = 3
    RERANK_TOP_K: int = 2
    MAX_CONCURRENT_REQUESTS: int = 10
    API_KEY: Optional[str] = None
    CORS_ORIGINS: List[str] = Field(default_factory=lambda: ["*"])

    class Config:
        env_file = ".env"

settings = Settings()

# app/services/vector_store.py
from app.core.postgres_db import postgres_manager
from app.services.embedding import get_embedding
from loguru import logger

class VectorStore:
    def __init__(self):
        self.embedding_model = get_embedding

    async def search(self, query: str, top_k: int = 5):
        """Поиск похожих документов"""
        try:
            # Получаем эмбеддинг запроса
            query_embedding = await self.embedding_model.embed_query(query)
            
            # Ищем в PostgreSQL
            results = await postgres_manager.search_similar(query_embedding, limit=top_k)
            
            logger.info(f"Найдено документов: {len(results)}")
            return results
            
        except Exception as e:
            logger.error(f"Ошибка поиска в векторной базе: {e}")
            return []

    async def add_documents(self, documents: list, metadatas: list = None):
        """Добавление документов в базу"""
        if metadatas is None:
            metadatas = [{}] * len(documents)

        success_count = 0
        for i, (doc, meta) in enumerate(zip(documents, metadatas)):
            try:
                # Получаем эмбеддинг документа
                embedding = await self.embedding_model.embed_query(doc)
                
                # Добавляем в PostgreSQL
                document_id = f"doc_{i}_{hash(doc)}"
                success = await postgres_manager.add_document(
                    content=doc,
                    embedding=embedding,
                    metadata=meta,
                    document_id=document_id
                )
                
                if success:
                    success_count += 1
                    
            except Exception as e:
                logger.error(f"Ошибка добавления документа {i}: {e}")

        logger.info(f"Успешно добавлено {success_count}/{len(documents)} документов")
        return success_count

# Глобальный экземпляр
vector_store = VectorStore()

# В начале файла
from app.core.postgres_db import postgres_manager

# В lifespan замените
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    logger.info("Запуск RAG системы с PostgreSQL и vLLM...")

    # Инициализация PostgreSQL
    try:
        postgres_manager.init_sync_connection()
        await postgres_manager.init_async_connection()
        logger.success("PostgreSQL подключен успешно")
    except Exception as e:
        logger.error(f"Ошибка подключения к PostgreSQL: {e}")

    # Остальной код...
