database

import asyncpg
from app.config import settings
from loguru import logger

class DatabaseManager:
    _pool = None
    _initialized = False

    @classmethod
    async def get_pool(cls):
        if cls._pool is None or cls._pool._closed:
            try:
                cls._pool = await asyncpg.create_pool(
                    settings.DATABASE_URL,
                    min_size=5,
                    max_size=20,
                    command_timeout=60,
                    max_inactive_connection_lifetime=300  # 5 minutes
                )
                cls._initialized = True
                logger.info("PostgreSQL connection pool created successfully")
                
                # Initialize database schema
                await cls._init_schema()
                
            except Exception as e:
                logger.error(f"Failed to create database connection pool: {e}")
                raise
        return cls._pool

    @classmethod
    async def _init_schema(cls):
        """Initialize database tables and indexes"""
        pool = await cls.get_pool()
        async with pool.acquire() as conn:
            # Enable vector extension
            await conn.execute("CREATE EXTENSION IF NOT EXISTS vector;")
            
            # Create documents table
            await conn.execute('''
                CREATE TABLE IF NOT EXISTS documents (
                    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                    content TEXT NOT NULL,
                    embedding VECTOR(384),
                    metadata JSONB DEFAULT '{}',
                    created_at TIMESTAMPTZ DEFAULT NOW(),
                    updated_at TIMESTAMPTZ DEFAULT NOW()
                );
            ''')
            
            # Create index for vector search
            await conn.execute('''
                CREATE INDEX IF NOT EXISTS documents_embedding_idx 
                ON documents USING ivfflat (embedding vector_cosine_ops)
                WITH (lists = 100);
            ''')
            
            # Create metadata index
            await conn.execute('''
                CREATE INDEX IF NOT EXISTS documents_metadata_idx 
                ON documents USING gin (metadata);
            ''')
            
            logger.info("Database schema initialized successfully")

    @classmethod
    async def close_pool(cls):
        if cls._pool and not cls._pool._closed:
            await cls._pool.close()
            cls._pool = None
            cls._initialized = False
            logger.info("Database connection pool closed")

    @classmethod
    def is_initialized(cls):
        return cls._initialized and cls._pool is not None and not cls._pool._closed

# Utility functions
async def get_database_pool():
    return await DatabaseManager.get_pool()

async def init_database():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    await DatabaseManager.get_pool()

async def close_database():
    """–ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö"""
    await DatabaseManager.close_pool()

def is_database_initialized():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    return DatabaseManager.is_initialized()

vector_store

import uuid
from typing import Any, Dict, List, Optional
import numpy as np

from app.config import settings
from app.core.database import get_database_pool, is_database_initialized
from app.services.embedding import embedding_service
from loguru import logger

class PGVectorStoreService:
    def __init__(self):
        self.embedding_dim = 384  # –†–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –¥–ª—è multilingual-MiniLM-L12-v2
        self.pool = None
        self.initialized = False

    async def init(self):
        """Initialize connection pool"""
        try:
            if not is_database_initialized():
                logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É–ª–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö...")
                self.pool = await get_database_pool()
                self.initialized = True
                logger.info("Vector store service initialized successfully")
            else:
                self.pool = await get_database_pool()
                self.initialized = True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ vector store: {e}")
            raise

    async def ensure_connection(self):
        """–£–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ"""
        if not self.initialized or self.pool is None or self.pool._closed:
            logger.warning("–ü—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...")
            await self.init()

    async def add_documents(
        self, documents: List[str], metadatas: List[Dict[str, Any]] = None
    ) -> List[str]:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤ –≤–µ–∫—Ç–æ—Ä–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ PostgreSQL"""
        if not documents:
            logger.warning("–ü–æ–ø—ã—Ç–∫–∞ –¥–æ–±–∞–≤–∏—Ç—å –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤")
            return []

        await self.ensure_connection()

        if metadatas is None:
            metadatas = [{}] * len(documents)
        elif len(metadatas) != len(documents):
            logger.warning("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤")
            metadatas = [{}] * len(documents)

        try:
            # –°–æ–∑–¥–∞–µ–º —ç–º–±–µ–¥–¥–∏–Ω–≥–∏
            logger.info(f"–°–æ–∑–¥–∞–Ω–∏–µ —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤ –¥–ª—è {len(documents)} –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤...")
            embeddings = embedding_service.encode(documents)

            ids = []
            async with self.pool.acquire() as conn:
                for i, (doc, embedding, metadata) in enumerate(zip(documents, embeddings, metadatas)):
                    doc_id = str(uuid.uuid4())
                    # Convert embedding to list for PostgreSQL
                    embedding_list = embedding.tolist() if hasattr(embedding, 'tolist') else embedding
                    
                    await conn.execute('''
                        INSERT INTO documents (id, content, embedding, metadata)
                        VALUES ($1, $2, $3, $4)
                    ''', doc_id, doc, embedding_list, metadata)
                    
                    ids.append(doc_id)

            logger.success(f"–î–æ–±–∞–≤–ª–µ–Ω–æ {len(documents)} –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤ PostgreSQL")
            return ids

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤ PostgreSQL: {e}")
            # –ü–æ–ø—Ä–æ–±—É–µ–º –ø–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø—É–ª –ø—Ä–∏ –æ—à–∏–±–∫–µ
            self.initialized = False
            raise

    async def search(self, query: str, top_k: Optional[int] = None) -> List[Dict[str, Any]]:
        """–ü–æ–∏—Å–∫ –ø–æ—Ö–æ–∂–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤ PostgreSQL"""
        if top_k is None:
            top_k = settings.TOP_K

        await self.ensure_connection()

        try:
            # –°–æ–∑–¥–∞–µ–º —ç–º–±–µ–¥–¥–∏–Ω–≥ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞
            query_embedding = embedding_service.encode(query)
            query_embedding_list = query_embedding.tolist() if hasattr(query_embedding, 'tolist') else query_embedding

            async with self.pool.acquire() as conn:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
                results = await conn.fetch('''
                    SELECT 
                        id,
                        content,
                        metadata,
                        1 - (embedding <=> $1) as similarity
                    FROM documents
                    ORDER BY embedding <=> $1
                    LIMIT $2
                ''', query_embedding_list, top_k)

                formatted_results = []
                for row in results:
                    formatted_results.append({
                        "id": str(row["id"]),
                        "document": row["content"],
                        "metadata": row["metadata"] or {},
                        "distance": 1 - float(row["similarity"]),
                        "score": float(row["similarity"])
                    })

                logger.debug(f"–ù–∞–π–¥–µ–Ω–æ {len(formatted_results)} —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤")
                return formatted_results

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –≤ PostgreSQL: {e}")
            # –ü–æ–ø—Ä–æ–±—É–µ–º –ø–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø—É–ª –ø—Ä–∏ –æ—à–∏–±–∫–µ
            self.initialized = False
            return []

    async def get_collection_info(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"""
        await self.ensure_connection()

        try:
            async with self.pool.acquire() as conn:
                count = await conn.fetchval("SELECT COUNT(*) FROM documents")
                return {
                    "database": "PostgreSQL",
                    "table_name": "documents",
                    "document_count": count,
                    "status": "healthy",
                    "vector_dimension": self.embedding_dim
                }
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–æ–ª–ª–µ–∫—Ü–∏–∏: {e}")
            self.initialized = False
            return {
                "database": "PostgreSQL",
                "table_name": "documents",
                "document_count": 0,
                "status": "error",
                "error": str(e)
            }

    async def delete_all_documents(self):
        """–£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)"""
        await self.ensure_connection()

        try:
            async with self.pool.acquire() as conn:
                await conn.execute("DELETE FROM documents")
                logger.info("–í—Å–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã —É–¥–∞–ª–µ–Ω—ã –∏–∑ PostgreSQL")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤: {e}")
            self.initialized = False
            raise

# Global instance
vector_store = PGVectorStoreService()

main

import os
import sys
import uvicorn
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse

from app.config import settings
from app.core.database import init_database, close_database
from app.services.vector_store import vector_store
from app.services.vllm_manager import vllm_manager, cleanup_all_vllm_processes
from app.utils.logger import setup_logger

# Import routers
from app.routers import health, chat, files

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup - –≤—Å–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω—ã –î–û yield
    try:
        print("üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö...")
        await init_database()
        
        print("üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞...")
        await vector_store.init()
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º vLLM —Å–µ—Ä–≤–µ—Ä (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è)
        print("üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è vLLM —Å–µ—Ä–≤–µ—Ä–∞...")
        if not vllm_manager.start_vllm_server():
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å vLLM —Å–µ—Ä–≤–µ—Ä. –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –±—É–¥–µ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.")
            raise RuntimeError("VLLM server failed to start")
        
        print("‚úÖ –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —É—Å–ø–µ—à–Ω–æ")
        
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
        # –ù–µ –ø–æ–¥–Ω–∏–º–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –µ—Å–ª–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å
        raise
    
    # –ü–æ—Å–ª–µ yield - –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
    yield
    
    # Shutdown - –æ—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
    try:
        print("üßπ –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã...")
        vllm_manager.stop_vllm_server()
        cleanup_all_vllm_processes()
        
        # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
        print("üßπ –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö...")
        await close_database()
        
        print("‚úÖ –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")
    except Exception as e:
        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏: {e}")

def create_app() -> FastAPI:
    """–°–æ–∑–¥–∞–Ω–∏–µ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    app = FastAPI(
        title="RAG System with vLLM",
        description="–°–∏—Å—Ç–µ–º–∞ RAG —Å vLLM –∏ PostgreSQL –¥–ª—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏",
        version="1.0.0",
        lifespan=lifespan
    )

    # CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.CORS_ORIGINS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Mount static files
    app.mount("/static", StaticFiles(directory="static"), name="static")

    # Include routers
    app.include_router(health.router, prefix="/api/v1", tags=["health"])
    app.include_router(chat.router, prefix="/api/v1", tags=["chat"])
    app.include_router(files.router, prefix="/api/v1", tags=["files"])

    @app.get("/")
    async def serve_frontend():
        """Serve the main frontend interface"""
        return FileResponse("static/index.html")

    @app.get("/api/v1")
    async def api_info():
        return {
            "name": "RAG API",
            "version": "1.0.0",
            "models": {
                "llm": settings.VLLM_MODEL_NAME,
                "embedding": settings.EMBEDDING_MODEL,
                "reranker": settings.RERANKER_MODEL
            }
        }
    
    return app

# –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
app = create_app()

def setup_environment():
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è"""
    os.makedirs("uploads", exist_ok=True)
    os.makedirs("logs", exist_ok=True)
    os.makedirs("static", exist_ok=True)

def print_startup_info():
    """–í—ã–≤–æ–¥–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–ø—É—Å–∫–µ"""
    print("\n" + "="*60)
    print("üöÄ –ó–∞–ø—É—Å–∫ RAG —Å–∏—Å—Ç–µ–º—ã —Å vLLM –∏ PostgreSQL")
    print("="*60)
    print("–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è:")
    print(f"   - –í–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: http://{settings.HOST}:{settings.PORT}")
    print(f"   - API: http://{settings.HOST}:{settings.PORT}/api/v1")
    print(f"   - vLLM: {settings.VLLM_BASE_URL}")
    print(f"   - –ú–æ–¥–µ–ª—å: {settings.VLLM_MODEL_NAME}")
    print(f"   - –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö: PostgreSQL —Å pgvector")
    print(f"   - –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è: http://{settings.HOST}:{settings.PORT}/docs")
    print()
    print("–î–æ—Å—Ç—É–ø–Ω—ã–µ endpoints:")
    print("   GET  /                   - –í–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å")
    print("   POST /api/v1/upload      - –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤")
    print("   POST /api/v1/chat        - –ß–∞—Ç —Å RAG")
    print("   GET  /api/v1/health      - –°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã")
    print("="*60)
    print()

def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞"""
    setup_environment()
    setup_logger()
    
    print_startup_info()

    try:
        uvicorn.run(
            "app.main:app",
            host=settings.HOST,
            port=settings.PORT,
            reload=True,
            log_level="info",
            access_log=True,
        )
    except KeyboardInterrupt:
        print("\nüõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è...")
    except Exception as e:
        print(f"\n‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
    finally:
        print("üëã –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ")

if __name__ == "__main__":
    main()

health

import os
import psutil
import asyncpg
from app.config import settings
from app.core.database import get_database_pool, is_database_initialized
from app.services.llm_service import llm_service
from fastapi import APIRouter, HTTPException
from loguru import logger

router = APIRouter()

@router.get("/health")
async def health_check():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∏—Å—Ç–µ–º—ã"""
    checks = {}

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ PostgreSQL
    try:
        if is_database_initialized():
            pool = await get_database_pool()
            async with pool.acquire() as conn:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ vector
                await conn.fetchval("SELECT 1")
                vector_ext = await conn.fetchval(
                    "SELECT installed_version FROM pg_available_extensions WHERE name = 'vector'"
                )
                checks["postgresql"] = {
                    "status": "healthy", 
                    "message": "Connected with vector extension",
                    "vector_version": vector_ext
                }
        else:
            checks["postgresql"] = {"status": "unhealthy", "message": "Database not initialized"}
    except Exception as e:
        checks["postgresql"] = {"status": "unhealthy", "message": str(e)}

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ vLLM
    try:
        test_response = llm_service.generate("–û—Ç–≤–µ—Ç—å 'OK'", max_tokens=5)
        checks["vllm"] = {
            "status": "healthy",
            "message": "Connected",
            "test_response": test_response.strip() if test_response else "No response"
        }
    except Exception as e:
        checks["vllm"] = {"status": "unhealthy", "message": str(e)}

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–º—è—Ç–∏
    memory = psutil.virtual_memory()
    checks["memory"] = {
        "total_gb": round(memory.total / (1024**3), 2),
        "available_gb": round(memory.available / (1024**3), 2),
        "used_percent": memory.percent,
    }

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∏—Å–∫–∞
    disk = psutil.disk_usage("/")
    checks["disk"] = {
        "total_gb": round(disk.total / (1024**3), 2),
        "free_gb": round(disk.free / (1024**3), 2),
        "used_percent": disk.percent,
    }

    # –û–±—â–∏–π —Å—Ç–∞—Ç—É—Å
    critical_services_healthy = all(
        checks[service]["status"] == "healthy" for service in ["postgresql", "vllm"]
    )

    overall_status = "healthy" if critical_services_healthy else "degraded"

    return {
        "status": overall_status, 
        "version": "1.0.0", 
        "checks": checks
    }
