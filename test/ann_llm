edit

import json
import csv
import time
import re
from openai import OpenAI

client = OpenAI(api_key="EMPTY", base_url="http://localhost:8000/v1")

def extract_clean_response(text):
    """Извлекает чистый ответ, убирая всё лишнее"""
    if text is None:
        return ""
    
    # Удаляем все теги форматирования и размышления
    clean_text = re.sub(r'<think>.*?</think>', '', text, flags=re.DOTALL)
    clean_text = re.sub(r'\*\*.*?\*\*', '', clean_text)  # Жирный текст
    clean_text = re.sub(r'\*.*?\*', '', clean_text)      # Курсив
    clean_text = re.sub(r'`.*?`', '', clean_text)        # Код
    clean_text = re.sub(r'#+', '', clean_text)           # Заголовки
    clean_text = re.sub(r'РАЗМЕЧЕННЫЙ ДИАЛОГ:?', '', clean_text, flags=re.IGNORECASE)
    clean_text = re.sub(r'РАЗМЕЧЕННЫЙ ТЕКСТ:?', '', clean_text, flags=re.IGNORECASE)
    clean_text = re.sub(r'АННОТИРОВАННЫЙ ТЕКСТ:?', '', clean_text, flags=re.IGNORECASE)
    
    # Убираем лишние пробелы и переносы
    clean_text = re.sub(r'\n+', ' ', clean_text)
    clean_text = re.sub(r'\s+', ' ', clean_text)
    
    return clean_text.strip()

def create_message_prompt(message_text):
    """Промпт для одного сообщения"""
    return f'''
Замени персональные данные на метки [FIO], [LOC], [PHONE_NUM], [LK_NUM], [EMAIL] в этом тексте:

{message_text}

Ответ (только текст с метками, без пояснений):
'''

def main():
    # Настройки
    input_file = "your_dataset.json"
    output_file = "annotated_messages.csv"
    max_dialogs = 2000
    
    # Загрузка датасета
    with open(input_file, 'r', encoding='utf-8') as f:
        dataset = json.load(f)
    
    print(f"Загружено диалогов: {len(dataset)}")
    
    # Создаем CSV файл
    with open(output_file, 'w', newline='', encoding='utf-8') as csvfile:
        fieldnames = ['id', 'original_message', 'annotated_message']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames, quoting=csv.QUOTE_ALL)
        
        writer.writeheader()
        
        total_messages = 0
        success_count = 0
        
        # Обработка диалогов
        for i, dialog in enumerate(dataset[:max_dialogs]):
            print(f"Обработка диалога {i+1}/{min(len(dataset), max_dialogs)} (ID: {dialog['id']})")
            
            # Обрабатываем каждое сообщение отдельно
            for message in dialog['dialogue']:
                original_text = message['text']
                
                # Очищаем оригинальный текст от переносов
                clean_original = re.sub(r'\n+', ' ', original_text)
                clean_original = re.sub(r'\s+', ' ', clean_original).strip()
                
                try:
                    # Отправляем запрос для одного сообщения
                    response = client.chat.completions.create(
                        model="Qwen3-8B-AWQ",
                        messages=[{
                            "role": "user", 
                            "content": create_message_prompt(clean_original)
                        }],
                        temperature=0.1,
                        max_tokens=2000
                    )
                    
                    result_text = response.choices[0].message.content
                    
                    # Очищаем ответ
                    clean_response = extract_clean_response(result_text)
                    
                    # Сохраняем в CSV
                    writer.writerow({
                        'id': dialog['id'],
                        'original_message': clean_original,
                        'annotated_message': clean_response
                    })
                    
                    success_count += 1
                    total_messages += 1
                    
                    print(f"  ✓ Сообщение {total_messages} обработано")
                    
                except Exception as e:
                    print(f"  ✗ Ошибка в сообщении: {str(e)}")
                    
                    # Сохраняем оригинал с пометкой об ошибке
                    writer.writerow({
                        'id': dialog['id'],
                        'original_message': clean_original,
                        'annotated_message': f"ОШИБКА: {str(e)}"
                    })
                    total_messages += 1
                
                # Пауза между запросами
                time.sleep(0.5)
    
    print(f"\n=== ИТОГ ===")
    print(f"Обработано сообщений: {total_messages}")
    print(f"Успешно: {success_count}")
    print(f"Файл сохранен: {output_file}")

if __name__ == "__main__":
    main()


-----------

import json
import time
from openai import OpenAI

# Настройка подключения к vLLM серверу
client = OpenAI(
    api_key="EMPTY",
    base_url="http://localhost:8000/v1"
)

def load_dataset(filename):
    """Загрузка датасета"""
    with open(filename, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_progress(annotated_data, filename):
    """Сохранение прогресса"""
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(annotated_data, f, ensure_ascii=False, indent=2)

def create_system_prompt():
    """Создание системного промпта с инструкциями"""
    return """Ты - ассистент для разметки персональных данных в диалогах технической поддержки.
    
ЗАДАЧА: Найди и замени все персональные данные в диалоге на соответствующие метки.

МЕТКИ ДЛЯ ЗАМЕНЫ:
- ФИО (полное или части) → [FIO]
- Место жительства (город, адрес) → [LOC] 
- Номер телефона → [PHONE_NUM]
- Email адрес → [EMAIL]

ПРАВИЛА:
1. Сохрани исходную структуру диалога
2. Заменяй ТОЛЬКО персональные данные, остальной текст оставляй без изменений
3. Используй метки точно как указано выше
4. Возвращай ТОЛЬКО размеченный диалог в формате JSON без дополнительных объяснений

ПРИМЕР РАЗМЕТКИ:
Вход: "Меня зовут Иван Иванов, телефон 89161234567, email ivan@mail.ru"
Выход: "Меня зовут [FIO], телефон [PHONE_NUM], email [EMAIL]"
"""

def annotate_dialogue(dialogue):
    """Разметка одного диалога с помощью модели"""
    
    # Формируем текст диалога для обработки
    dialogue_text = ""
    for message in dialogue:
        dialogue_text += f"{message['role']}: {message['text']}\n"
    
    user_prompt = f"""
    Разметь следующий диалог, заменив персональные данные на метки:
    
    {dialogue_text}
    
    Верни ТОЛЬКО размеченный диалог в том же формате (список словарей с role и text).
    """
    
    try:
        response = client.chat.completions.create(
            model="Qwen/Qwen3-8B-AWQ",
            messages=[
                {"role": "system", "content": create_system_prompt()},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.1,
            max_tokens=4000
        )
        
        result = response.choices[0].message.content
        
        # Парсим ответ модели (может быть JSON или текстом)
        try:
            # Пытаемся распарсить как JSON
            annotated_dialogue = json.loads(result)
            return annotated_dialogue
        except json.JSONDecodeError:
            # Если не JSON, пытаемся извлечь структуру другим способом
            print(f"Модель вернула не JSON. Ответ: {result}")
            return None
            
    except Exception as e:
        print(f"Ошибка при запросе к модели: {e}")
        return None

def main():
    # Настройки
    input_file = "your_dataset.json"  # Ваш исходный файл
    output_file = "annotated_dataset.json"  # Файл для результатов
    start_index = 0  # С какого диалога начать
    max_dialogs = 2000  # Сколько диалогов обработать
    
    # Загрузка датасета
    dataset = load_dataset(input_file)
    print(f"Загружено диалогов: {len(dataset)}")
    
    # Загрузка существующих результатов (если продолжаем)
    try:
        annotated_data = load_dataset(output_file)
        print(f"Найдены существующие результаты: {len(annotated_data)} диалогов")
    except FileNotFoundError:
        annotated_data = []
        print("Начинаем новую разметку...")
    
    # Определяем диапазон для обработки
    end_index = min(start_index + max_dialogs, len(dataset))
    
    # Обработка диалогов
    for i in range(start_index, end_index):
        original_dialog = dataset[i]
        print(f"Обработка диалога {i+1}/{len(dataset)} (ID: {original_dialog['id']})")
        
        # Разметка диалога
        annotated_dialogue = annotate_dialogue(original_dialog['dialogue'])
        
        if annotated_dialogue:
            # Создаем размеченный диалог
            annotated_dialog = original_dialog.copy()
            annotated_dialog['dialogue'] = annotated_dialogue
            annotated_dialog['annotated'] = True  # Помечаем как размеченный
            annotated_dialog['annotation_timestamp'] = time.time()
            
            annotated_data.append(annotated_dialog)
            
            # Сохраняем прогресс после каждого диалога
            save_progress(annotated_data, output_file)
            print(f"✓ Диалог {i+1} размечен и сохранен")
        else:
            print(f"✗ Ошибка разметки диалога {i+1}")
        
        # Небольшая пауза между запросами
        time.sleep(1)
    
    print(f"Готово! Обработано {len(annotated_data)} диалогов")
    print(f"Результаты сохранены в {output_file}")

if __name__ == "__main__":
    main()
