import csv
import time
import re
import json
from concurrent.futures import ThreadPoolExecutor, as_completed
from openai import OpenAI

client = OpenAI(api_key="EMPTY", base_url="http://localhost:8000/v1")

def extract_clean_response(text):
    """Извлекает чистый ответ, убирая всё лишнее"""
    if text is None:
        return ""

    # Удаляем все теги форматирования и размышления
    clean_text = re.sub(r'<think>.*?</think>', '', text, flags=re.DOTALL)
    clean_text = re.sub(r'\*\*.*?\*\*', '', clean_text)  # Жирный текст
    clean_text = re.sub(r'\*.*?\*', '', clean_text)      # Курсив
    clean_text = re.sub(r'`.*?`', '', clean_text)        # Код
    clean_text = re.sub(r'#+', '', clean_text)           # Заголовки
    clean_text = re.sub(r'РАЗМЕЧЕННЫЙ ДИАЛОГ:?', '', clean_text, flags=re.IGNORECASE)
    clean_text = re.sub(r'РАЗМЕЧЕННЫЙ ТЕКСТ:?', '', clean_text, flags=re.IGNORECASE)
    clean_text = re.sub(r'АННОТИРОВАННЫЙ ТЕКСТ:?', '', clean_text, flags=re.IGNORECASE)

    # Убираем лишние пробелы и переносы
    clean_text = re.sub(r'\n+', ' ', clean_text)
    clean_text = re.sub(r'\s+', ' ', clean_text)

    return clean_text.strip()

def create_message_prompt(message_text):
    """Промпт для одного сообщения"""
    return f'''
Замени персональные данные на метки [FIO], [LOC], [PHONE_NUM], [LK_NUM], [EMAIL] в этом тексте.
Верни ТОЛЬКО размеченный текст без каких-либо пояснений, без тегов <think>, без нумерации.

Текст: {message_text}

Размеченный текст:
'''

def process_single_message(message_data):
    """Обрабатывает одно сообщение"""
    dialog_id = message_data['dialog_id']
    original_text = message_data['original_text']
    message_index = message_data['message_index']
    
    # Очищаем оригинальный текст
    clean_original = re.sub(r'\n+', ' ', original_text)
    clean_original = re.sub(r'\s+', ' ', clean_original).strip()
    
    prompt = create_message_prompt(clean_original)
    
    print(f"\n=== ЗАПРОС {message_index} ДЛЯ ДИАЛОГА {dialog_id} ===")
    print(f"Промпт: {prompt}")
    print("=" * 50)
    
    try:
        # Отправляем запрос для одного сообщения
        response = client.chat.completions.create(
            model="Qwen3-8B-AWQ",
            messages=[{
                "role": "user",
                "content": prompt
            }],
            temperature=0.1,
            max_tokens=2000,
            timeout=60  # Таймаут 60 секунд на запрос
        )

        result_text = response.choices[0].message.content
        
        print(f"\n=== ОТВЕТ {message_index} ДЛЯ ДИАЛОГА {dialog_id} ===")
        print(f"Полный ответ: {result_text}")
        print("=" * 50)
        
        # Очищаем ответ
        clean_response = extract_clean_response(result_text)
        
        # Проверяем, не пустой ли ответ
        if not clean_response or len(clean_response.strip()) < 5:
            clean_response = clean_original  # Если ответ пустой, сохраняем оригинал
            print(f"Предупреждение: пустой ответ для сообщения {message_index}")
        
        return {
            'dialog_id': dialog_id,
            'original_message': clean_original,
            'annotated_message': clean_response,
            'success': True,
            'message_index': message_index
        }
        
    except Exception as e:
        print(f"Ошибка в сообщении {message_index} диалога {dialog_id}: {str(e)}")
        return {
            'dialog_id': dialog_id,
            'original_message': clean_original,
            'annotated_message': f"ОШИБКА: {str(e)}",
            'success': False,
            'message_index': message_index
        }

def main():
    # Настройки
    input_file = "your_dataset.json"
    output_file = "annotated_messages.csv"
    max_dialogs = 2000
    batch_size = 8  # Количество параллельных запросов
    max_workers = 8  # Количество потоков для параллельной обработки
    
    # Загрузка датасета
    with open(input_file, 'r', encoding='utf-8') as f:
        dataset = json.load(f)

    print(f"Загружено диалогов: {len(dataset)}")
    
    # Ограничиваем количество обрабатываемых диалогов
    dialogs_to_process = dataset[:max_dialogs]
    
    # Собираем все сообщения в один список для параллельной обработки
    all_messages = []
    message_counter = 0
    
    for dialog in dialogs_to_process:
        dialog_id = dialog['id']
        for message_index, message in enumerate(dialog['dialogue']):
            all_messages.append({
                'dialog_id': dialog_id,
                'original_text': message['text'],
                'message_index': message_counter,
                'dialog_message_index': message_index
            })
            message_counter += 1
    
    print(f"Всего сообщений для обработки: {len(all_messages)}")
    
    # Создаем CSV файл
    with open(output_file, 'w', newline='', encoding='utf-8') as csvfile:
        fieldnames = ['dialog_id', 'original_message', 'annotated_message']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames, quoting=csv.QUOTE_ALL)
        writer.writeheader()
        
        total_processed = 0
        success_count = 0
        
        # Разбиваем на батчи
        batches = [all_messages[i:i + batch_size] for i in range(0, len(all_messages), batch_size)]
        
        for batch_num, batch in enumerate(batches):
            print(f"\nОбработка батча {batch_num + 1}/{len(batches)} (сообщений: {len(batch)})")
            
            # Обрабатываем батч параллельно
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                # Запускаем все задачи в батче
                future_to_message = {
                    executor.submit(process_single_message, message_data): message_data 
                    for message_data in batch
                }
                
                # Собираем результаты по мере завершения
                batch_results = []
                for future in as_completed(future_to_message):
                    message_data = future_to_message[future]
                    try:
                        result = future.result()
                        batch_results.append(result)
                    except Exception as e:
                        print(f"Неожиданная ошибка при обработке сообщения: {str(e)}")
                        # Создаем результат с ошибкой
                        batch_results.append({
                            'dialog_id': message_data['dialog_id'],
                            'original_message': message_data['original_text'],
                            'annotated_message': f"ОШИБКА БАТЧА: {str(e)}",
                            'success': False,
                            'message_index': message_data['message_index']
                        })
                
                # Сортируем результаты по индексу сообщения для сохранения порядка
                batch_results.sort(key=lambda x: x['message_index'])
                
                # Записываем результаты в CSV
                for result in batch_results:
                    writer.writerow({
                        'dialog_id': result['dialog_id'],
                        'original_message': result['original_message'],
                        'annotated_message': result['annotated_message']
                    })
                    
                    if result['success']:
                        success_count += 1
                    total_processed += 1
                
                print(f"Батч {batch_num + 1} обработан. Успешно: {sum(1 for r in batch_results if r['success'])}/{len(batch)}")
            
            # Пауза между батчами чтобы не перегружать систему
            time.sleep(2)
            
            # Прогресс
            progress = (batch_num + 1) / len(batches) * 100
            print(f"Общий прогресс: {progress:.1f}% ({total_processed}/{len(all_messages)})")
    
    print(f"\n=== ИТОГ ===")
    print(f"Обработано сообщений: {total_processed}")
    print(f"Успешно: {success_count}")
    print(f"Файл сохранен: {output_file}")

if __name__ == "__main__":
    main()
