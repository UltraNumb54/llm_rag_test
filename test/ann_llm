edit

import json
import csv
import time
import re
from openai import OpenAI

client = OpenAI(api_key="EMPTY", base_url="http://localhost:8000/v1")

def extract_clean_response(text):
    """Извлекает чистый ответ модели, убирая think-блоки"""
    if text is None:
        return ""
    
    # Удаляем блоки размышлений в различных форматах
    clean_text = re.sub(r'<think>.*?</think>', '', text, flags=re.DOTALL)
    clean_text = re.sub(r'思考.*?\n', '', clean_text, flags=re.DOTALL)
    clean_text = re.sub(r'Reasoning:.*?\n', '', clean_text, flags=re.DOTALL)
    clean_text = re.sub(r'Размышляю:.*?\n', '', clean_text, flags=re.DOTALL)
    
    # Убираем маркеры размышлений
    lines = clean_text.strip().split('\n')
    clean_lines = []
    
    for line in lines:
        line = line.strip()
        # Пропускаем строки с размышлениями
        if any(word in line.lower() for word in ['think', 'размышляю', 'сначала', 'итак', 'reasoning', 'thought:']):
            continue
        if line and not line.startswith('//') and not line.startswith('#'):
            clean_lines.append(line)
    
    result = '\n'.join(clean_lines).strip()
    return result if result else "ОШИБКА: Пустой ответ"

def create_simple_prompt(dialogue_text):
    """Создает простой промпт"""
    return f'''
Замени все персональные данные в диалоге на метки: [FIO], [LOC], [PHONE_NUM], [LK_NUM], [EMAIL]

ДИАЛОГ:
{dialogue_text}

РАЗМЕЧЕННЫЙ ДИАЛОГ:
'''

def format_dialogue_for_csv(dialogue):
    """Форматирует диалог в строку для CSV"""
    parts = []
    for msg in dialogue:
        parts.append(f"{msg['role']}: {msg['text']}")
    return " | ".join(parts)

def main():
    # Настройки
    input_file = "your_dataset.json"
    output_file = "annotated_dataset.csv"
    max_dialogs = 2000
    
    # Загрузка датасета
    with open(input_file, 'r', encoding='utf-8') as f:
        dataset = json.load(f)
    
    print(f"Загружено диалогов: {len(dataset)}")
    
    # Создаем CSV файл
    with open(output_file, 'w', newline='', encoding='utf-8') as csvfile:
        fieldnames = ['id', 'topic', 'source', 'original_dialogue', 'annotated_dialogue', 'timestamp']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames, quoting=csv.QUOTE_ALL)
        
        writer.writeheader()
        
        success_count = 0
        fail_count = 0
        
        # Обработка диалогов
        for i, dialog in enumerate(dataset[:max_dialogs]):
            print(f"\n--- Обработка {i+1}/{min(len(dataset), max_dialogs)} (ID: {dialog['id']}) ---")
            
            # Форматируем оригинальный диалог
            original_dialogue = format_dialogue_for_csv(dialog['dialogue'])
            
            try:
                # Отправляем запрос модели
                response = client.chat.completions.create(
                    model="Qwen/Qwen3-8B-AWQ",
                    messages=[{
                        "role": "user", 
                        "content": create_simple_prompt(original_dialogue)
                    }],
                    temperature=0.1,
                    max_tokens=4000
                )
                
                result_text = response.choices[0].message.content
                print(f"Ответ получен, длина: {len(result_text)} символов")
                
                # Очищаем ответ от размышлений
                clean_response = extract_clean_response(result_text)
                
                # Сохраняем в CSV
                writer.writerow({
                    'id': dialog['id'],
                    'topic': dialog['topic'],
                    'source': dialog['source'],
                    'original_dialogue': original_dialogue,
                    'annotated_dialogue': clean_response,
                    'timestamp': time.time()
                })
                
                success_count += 1
                print(f"✓ Успешно сохранен диалог ID: {dialog['id']}")
                
            except Exception as e:
                error_msg = f"ОШИБКА: {str(e)}"
                print(f"✗ Ошибка при обработке диалога ID: {dialog['id']}: {error_msg}")
                
                # Сохраняем диалог с ошибкой
                writer.writerow({
                    'id': dialog['id'],
                    'topic': dialog['topic'],
                    'source': dialog['source'],
                    'original_dialogue': original_dialogue,
                    'annotated_dialogue': error_msg,
                    'timestamp': time.time()
                })
                
                fail_count += 1
            
            # Пауза между запросами
            time.sleep(1)
    
    print(f"\n=== ИТОГ ===")
    print(f"Успешно: {success_count}")
    print(f"С ошибками: {fail_count}")
    print(f"Результаты сохранены в: {output_file}")

if __name__ == "__main__":
    main()


-----------

import json
import time
from openai import OpenAI

# Настройка подключения к vLLM серверу
client = OpenAI(
    api_key="EMPTY",
    base_url="http://localhost:8000/v1"
)

def load_dataset(filename):
    """Загрузка датасета"""
    with open(filename, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_progress(annotated_data, filename):
    """Сохранение прогресса"""
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(annotated_data, f, ensure_ascii=False, indent=2)

def create_system_prompt():
    """Создание системного промпта с инструкциями"""
    return """Ты - ассистент для разметки персональных данных в диалогах технической поддержки.
    
ЗАДАЧА: Найди и замени все персональные данные в диалоге на соответствующие метки.

МЕТКИ ДЛЯ ЗАМЕНЫ:
- ФИО (полное или части) → [FIO]
- Место жительства (город, адрес) → [LOC] 
- Номер телефона → [PHONE_NUM]
- Email адрес → [EMAIL]

ПРАВИЛА:
1. Сохрани исходную структуру диалога
2. Заменяй ТОЛЬКО персональные данные, остальной текст оставляй без изменений
3. Используй метки точно как указано выше
4. Возвращай ТОЛЬКО размеченный диалог в формате JSON без дополнительных объяснений

ПРИМЕР РАЗМЕТКИ:
Вход: "Меня зовут Иван Иванов, телефон 89161234567, email ivan@mail.ru"
Выход: "Меня зовут [FIO], телефон [PHONE_NUM], email [EMAIL]"
"""

def annotate_dialogue(dialogue):
    """Разметка одного диалога с помощью модели"""
    
    # Формируем текст диалога для обработки
    dialogue_text = ""
    for message in dialogue:
        dialogue_text += f"{message['role']}: {message['text']}\n"
    
    user_prompt = f"""
    Разметь следующий диалог, заменив персональные данные на метки:
    
    {dialogue_text}
    
    Верни ТОЛЬКО размеченный диалог в том же формате (список словарей с role и text).
    """
    
    try:
        response = client.chat.completions.create(
            model="Qwen/Qwen3-8B-AWQ",
            messages=[
                {"role": "system", "content": create_system_prompt()},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.1,
            max_tokens=4000
        )
        
        result = response.choices[0].message.content
        
        # Парсим ответ модели (может быть JSON или текстом)
        try:
            # Пытаемся распарсить как JSON
            annotated_dialogue = json.loads(result)
            return annotated_dialogue
        except json.JSONDecodeError:
            # Если не JSON, пытаемся извлечь структуру другим способом
            print(f"Модель вернула не JSON. Ответ: {result}")
            return None
            
    except Exception as e:
        print(f"Ошибка при запросе к модели: {e}")
        return None

def main():
    # Настройки
    input_file = "your_dataset.json"  # Ваш исходный файл
    output_file = "annotated_dataset.json"  # Файл для результатов
    start_index = 0  # С какого диалога начать
    max_dialogs = 2000  # Сколько диалогов обработать
    
    # Загрузка датасета
    dataset = load_dataset(input_file)
    print(f"Загружено диалогов: {len(dataset)}")
    
    # Загрузка существующих результатов (если продолжаем)
    try:
        annotated_data = load_dataset(output_file)
        print(f"Найдены существующие результаты: {len(annotated_data)} диалогов")
    except FileNotFoundError:
        annotated_data = []
        print("Начинаем новую разметку...")
    
    # Определяем диапазон для обработки
    end_index = min(start_index + max_dialogs, len(dataset))
    
    # Обработка диалогов
    for i in range(start_index, end_index):
        original_dialog = dataset[i]
        print(f"Обработка диалога {i+1}/{len(dataset)} (ID: {original_dialog['id']})")
        
        # Разметка диалога
        annotated_dialogue = annotate_dialogue(original_dialog['dialogue'])
        
        if annotated_dialogue:
            # Создаем размеченный диалог
            annotated_dialog = original_dialog.copy()
            annotated_dialog['dialogue'] = annotated_dialogue
            annotated_dialog['annotated'] = True  # Помечаем как размеченный
            annotated_dialog['annotation_timestamp'] = time.time()
            
            annotated_data.append(annotated_dialog)
            
            # Сохраняем прогресс после каждого диалога
            save_progress(annotated_data, output_file)
            print(f"✓ Диалог {i+1} размечен и сохранен")
        else:
            print(f"✗ Ошибка разметки диалога {i+1}")
        
        # Небольшая пауза между запросами
        time.sleep(1)
    
    print(f"Готово! Обработано {len(annotated_data)} диалогов")
    print(f"Результаты сохранены в {output_file}")

if __name__ == "__main__":
    main()
