import json
import csv
import time
import re
import ast
from openai import OpenAI

client = OpenAI(api_key="EMPTY", base_url="http://localhost:8000/v1")

def extract_clean_response(text):
    """Извлекает чистый ответ, убирая всё лишнее"""
    if text is None:
        return ""
    
    # Удаляем все теги форматирования и размышления
    clean_text = re.sub(r'<think>.*?</think>', '', text, flags=re.DOTALL)
    clean_text = re.sub(r'\*\*.*?\*\*', '', clean_text)  # Жирный текст
    clean_text = re.sub(r'\*.*?\*', '', clean_text)      # Курсив
    clean_text = re.sub(r'`.*?`', '', clean_text)        # Код
    clean_text = re.sub(r'#+', '', clean_text)           # Заголовки
    clean_text = re.sub(r'РАЗМЕЧЕННЫЙ ДИАЛОГ:?', '', clean_text, flags=re.IGNORECASE)
    clean_text = re.sub(r'РАЗМЕЧЕННЫЙ ТЕКСТ:?', '', clean_text, flags=re.IGNORECASE)
    clean_text = re.sub(r'АННОТИРОВАННЫЙ ТЕКСТ:?', '', clean_text, flags=re.IGNORECASE)
    clean_text = re.sub(r'CSV:?', '', clean_text, flags=re.IGNORECASE)
    clean_text = re.sub(r'JSON:?', '', clean_text, flags=re.IGNORECASE)
    
    # Убираем лишние пробелы и переносы
    clean_text = re.sub(r'\n+', ' ', clean_text)
    clean_text = re.sub(r'\s+', ' ', clean_text)
    
    return clean_text.strip()

def create_dialog_prompt(dialog_messages):
    """Промпт для всего диалога с возвратом в CSV формате"""
    messages_text = "\n".join([f"{i+1}. {msg['text']}" for i, msg in enumerate(dialog_messages)])
    
    return f'''
Перед тобой диалог из {len(dialog_messages)} сообщений. Замени все персональные данные в КАЖДОМ сообщении на соответствующие метки:

[FIO] - ФИО, имена, фамилии, отчества
[LOC] - адреса, местоположения, города
[PHONE_NUM] - номера телефонов
[LK_NUM] - номера личных карт, договоров, счетов
[EMAIL] - email адреса

Диалог:
{messages_text}

Верни ТОЛЬКО CSV формат со следующими колонками:
message_id,original_text,annotated_text

Где:
- message_id: номер сообщения (1, 2, 3...)
- original_text: оригинальный текст сообщения
- annotated_text: текст с замененными персональными данными

Пример:
1,"Иванов Иван приедет по адресу Ленина 25","[FIO] приедет по адресу [LOC]"
2,"Мой телефон 89151234567","Мой телефон [PHONE_NUM]"

Твой ответ (только CSV, без пояснений):
'''

def parse_csv_response(response_text, dialog_messages):
    """Парсит CSV ответ от модели и валидирует его"""
    try:
        # Очищаем ответ
        clean_response = extract_clean_response(response_text)
        
        # Разбиваем на строки
        lines = [line.strip() for line in clean_response.split('\n') if line.strip()]
        
        results = []
        
        for line in lines:
            # Пропускаем заголовок если есть
            if line.lower().startswith('message_id') or line.lower().startswith('id'):
                continue
                
            # Парсим CSV строку
            if line.count(',') >= 2:
                parts = line.split(',', 2)
                if len(parts) >= 3:
                    message_id = parts[0].strip()
                    original_text = parts[1].strip().strip('"')
                    annotated_text = parts[2].strip().strip('"')
                    
                    # Валидация message_id
                    try:
                        msg_id = int(message_id)
                        if 1 <= msg_id <= len(dialog_messages):
                            results.append({
                                'message_id': msg_id,
                                'original_text': original_text,
                                'annotated_text': annotated_text
                            })
                    except ValueError:
                        continue
        
        # Проверяем, что получили все сообщения
        if len(results) == len(dialog_messages):
            # Сортируем по message_id
            results.sort(key=lambda x: x['message_id'])
            return results
        
        return None
        
    except Exception as e:
        print(f"Ошибка парсинга CSV: {e}")
        return None

def main():
    # Настройки
    input_file = "your_dataset.json"
    output_file = "annotated_messages.csv"
    max_dialogs = 2000
    
    # Загрузка датасета
    with open(input_file, 'r', encoding='utf-8') as f:
        dataset = json.load(f)
    
    print(f"Загружено диалогов: {len(dataset)}")
    
    # Создаем CSV файл
    with open(output_file, 'w', newline='', encoding='utf-8') as csvfile:
        fieldnames = ['dialog_id', 'message_id', 'original_message', 'annotated_message']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames, quoting=csv.QUOTE_ALL)
        
        writer.writeheader()
        
        total_dialogs = 0
        total_messages = 0
        success_dialogs = 0
        success_messages = 0
        
        # Обработка диалогов
        for i, dialog in enumerate(dataset[:max_dialogs]):
            print(f"Обработка диалога {i+1}/{min(len(dataset), max_dialogs)} (ID: {dialog['id']})")
            
            dialog_id = dialog['id']
            dialog_messages = dialog['dialogue']
            
            # Подготавливаем сообщения диалога
            prepared_messages = []
            for msg in dialog_messages:
                clean_text = re.sub(r'\n+', ' ', msg['text'])
                clean_text = re.sub(r'\s+', ' ', clean_text).strip()
                prepared_messages.append({'text': clean_text})
            
            try:
                # Отправляем весь диалог одним запросом
                response = client.chat.completions.create(
                    model="Qwen3-8B-AWQ",
                    messages=[{
                        "role": "user", 
                        "content": create_dialog_prompt(prepared_messages)
                    }],
                    temperature=0.1,
                    max_tokens=4000
                )
                
                result_text = response.choices[0].message.content
                
                # Парсим CSV ответ
                parsed_results = parse_csv_response(result_text, prepared_messages)
                
                if parsed_results:
                    # Успешно распарсили CSV
                    for result in parsed_results:
                        writer.writerow({
                            'dialog_id': dialog_id,
                            'message_id': result['message_id'],
                            'original_message': result['original_text'],
                            'annotated_message': result['annotated_text']
                        })
                        success_messages += 1
                        total_messages += 1
                    
                    success_dialogs += 1
                    print(f"  ✓ Диалог обработан целиком ({len(parsed_results)} сообщений)")
                    
                else:
                    # Не удалось распарсить CSV - обрабатываем каждое сообщение отдельно
                    print(f"  ⚠ CSV парсинг не удался, обрабатываю сообщения по отдельности")
                    
                    for j, message in enumerate(prepared_messages):
                        original_text = message['text']
                        
                        try:
                            single_response = client.chat.completions.create(
                                model="Qwen3-8B-AWQ",
                                messages=[{
                                    "role": "user", 
                                    "content": f'Замени персональные данные на метки [FIO], [LOC], [PHONE_NUM], [LK_NUM], [EMAIL] в этом тексте: {original_text}\n\nОтвет (только текст с метками, без пояснений):'
                                }],
                                temperature=0.1,
                                max_tokens=2000
                            )
                            
                            single_result = single_response.choices[0].message.content
                            clean_single_result = extract_clean_response(single_result)
                            
                            writer.writerow({
                                'dialog_id': dialog_id,
                                'message_id': j + 1,
                                'original_message': original_text,
                                'annotated_message': clean_single_result
                            })
                            
                            success_messages += 1
                            total_messages += 1
                            print(f"    ✓ Сообщение {j+1} обработано")
                            
                        except Exception as e:
                            print(f"    ✗ Ошибка в сообщении {j+1}: {str(e)}")
                            writer.writerow({
                                'dialog_id': dialog_id,
                                'message_id': j + 1,
                                'original_message': original_text,
                                'annotated_message': f"ОШИБКА: {str(e)}"
                            })
                            total_messages += 1
                        
                        time.sleep(0.2)
                
                total_dialogs += 1
                
            except Exception as e:
                print(f"  ✗ Ошибка в диалоге: {str(e)}")
                # Сохраняем все сообщения с пометкой об ошибке
                for j, message in enumerate(prepared_messages):
                    writer.writerow({
                        'dialog_id': dialog_id,
                        'message_id': j + 1,
                        'original_message': message['text'],
                        'annotated_message': f"ОШИБКА ДИАЛОГА: {str(e)}"
                    })
                    total_messages += 1
                
                total_dialogs += 1
            
            # Пауза между диалогами
            time.sleep(1)
    
    print(f"\n=== ИТОГ ===")
    print(f"Обработано диалогов: {total_dialogs}")
    print(f"Успешных диалогов: {success_dialogs}")
    print(f"Обработано сообщений: {total_messages}")
    print(f"Успешных сообщений: {success_messages}")
    print(f"Файл сохранен: {output_file}")

if __name__ == "__main__":
    main()
