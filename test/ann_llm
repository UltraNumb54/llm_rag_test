import json
import time
from openai import OpenAI

# Настройка подключения к vLLM серверу
client = OpenAI(
    api_key="EMPTY",
    base_url="http://localhost:8000/v1"
)

def load_dataset(filename):
    """Загрузка датасета"""
    with open(filename, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_progress(annotated_data, filename):
    """Сохранение прогресса"""
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(annotated_data, f, ensure_ascii=False, indent=2)

def create_system_prompt():
    """Создание системного промпта с инструкциями"""
    return """Ты - ассистент для разметки персональных данных в диалогах технической поддержки.
    
ЗАДАЧА: Найди и замени все персональные данные в диалоге на соответствующие метки.

МЕТКИ ДЛЯ ЗАМЕНЫ:
- ФИО (полное или части) → [FIO]
- Место жительства (город, адрес) → [LOC] 
- Номер телефона → [PHONE_NUM]
- Email адрес → [EMAIL]

ПРАВИЛА:
1. Сохрани исходную структуру диалога
2. Заменяй ТОЛЬКО персональные данные, остальной текст оставляй без изменений
3. Используй метки точно как указано выше
4. Возвращай ТОЛЬКО размеченный диалог в формате JSON без дополнительных объяснений

ПРИМЕР РАЗМЕТКИ:
Вход: "Меня зовут Иван Иванов, телефон 89161234567, email ivan@mail.ru"
Выход: "Меня зовут [FIO], телефон [PHONE_NUM], email [EMAIL]"
"""

def annotate_dialogue(dialogue):
    """Разметка одного диалога с помощью модели"""
    
    # Формируем текст диалога для обработки
    dialogue_text = ""
    for message in dialogue:
        dialogue_text += f"{message['role']}: {message['text']}\n"
    
    user_prompt = f"""
    Разметь следующий диалог, заменив персональные данные на метки:
    
    {dialogue_text}
    
    Верни ТОЛЬКО размеченный диалог в том же формате (список словарей с role и text).
    """
    
    try:
        response = client.chat.completions.create(
            model="Qwen/Qwen3-8B-AWQ",
            messages=[
                {"role": "system", "content": create_system_prompt()},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.1,
            max_tokens=4000
        )
        
        result = response.choices[0].message.content
        
        # Парсим ответ модели (может быть JSON или текстом)
        try:
            # Пытаемся распарсить как JSON
            annotated_dialogue = json.loads(result)
            return annotated_dialogue
        except json.JSONDecodeError:
            # Если не JSON, пытаемся извлечь структуру другим способом
            print(f"Модель вернула не JSON. Ответ: {result}")
            return None
            
    except Exception as e:
        print(f"Ошибка при запросе к модели: {e}")
        return None

def main():
    # Настройки
    input_file = "your_dataset.json"  # Ваш исходный файл
    output_file = "annotated_dataset.json"  # Файл для результатов
    start_index = 0  # С какого диалога начать
    max_dialogs = 2000  # Сколько диалогов обработать
    
    # Загрузка датасета
    dataset = load_dataset(input_file)
    print(f"Загружено диалогов: {len(dataset)}")
    
    # Загрузка существующих результатов (если продолжаем)
    try:
        annotated_data = load_dataset(output_file)
        print(f"Найдены существующие результаты: {len(annotated_data)} диалогов")
    except FileNotFoundError:
        annotated_data = []
        print("Начинаем новую разметку...")
    
    # Определяем диапазон для обработки
    end_index = min(start_index + max_dialogs, len(dataset))
    
    # Обработка диалогов
    for i in range(start_index, end_index):
        original_dialog = dataset[i]
        print(f"Обработка диалога {i+1}/{len(dataset)} (ID: {original_dialog['id']})")
        
        # Разметка диалога
        annotated_dialogue = annotate_dialogue(original_dialog['dialogue'])
        
        if annotated_dialogue:
            # Создаем размеченный диалог
            annotated_dialog = original_dialog.copy()
            annotated_dialog['dialogue'] = annotated_dialogue
            annotated_dialog['annotated'] = True  # Помечаем как размеченный
            annotated_dialog['annotation_timestamp'] = time.time()
            
            annotated_data.append(annotated_dialog)
            
            # Сохраняем прогресс после каждого диалога
            save_progress(annotated_data, output_file)
            print(f"✓ Диалог {i+1} размечен и сохранен")
        else:
            print(f"✗ Ошибка разметки диалога {i+1}")
        
        # Небольшая пауза между запросами
        time.sleep(1)
    
    print(f"Готово! Обработано {len(annotated_data)} диалогов")
    print(f"Результаты сохранены в {output_file}")

if __name__ == "__main__":
    main()
